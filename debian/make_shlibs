#! /bin/bash

set -e
umask 022

# this could be done with dpkg-parsechangelog -S, but that only works since
# dpkg 1.17, so we want to avoid this to enable backports
DEB_VERSION=`dpkg-parsechangelog |grep ^Version: | awk '{ print $2 }'`
DEB_HOST_MULTIARCH=`dpkg-architecture -qDEB_HOST_MULTIARCH`


make_shlibs() {
	pkg=$1
	echo $pkg
	PKGDIR=debian/$pkg/DEBIAN

	# step 1:
	# - create symbols files:
	#   - we only want symbols for public libraries (so exclude private
	#   ones)
	#   - we want to fail if new symbols appear, which are not listed in
	#   the symbols file (dpkg-gensymbols -c4)
	# - create first part of the shlibs file:
	#   for public libraries, we want a weak dependency in the shlibs file
	dh_makeshlibs -p$pkg -V -X/usr/lib/${DEB_HOST_MULTIARCH}/samba -X/usr/lib/${DEB_HOST_MULTIARCH}/plugin -- -c4
	[ -e $PKGDIR/shlibs ] && mv $PKGDIR/shlibs $PKGDIR/shlibs.1

	# step 2:
	# - ignore the symbols file generated by this step (it might contain
	#   private symbols):
	#   - output to /dev/null (-O/dev/null)
	#   - don't print info about new symbols (-q)
	# - create second part of the shlibs file:
	#   for private libraries, we want a strict dependency in the shlibs
	#   file
	#   this step will generate a strict dependency for all libraries (also
	#   public ones), so afterwards, we will have to merge them
	dh_makeshlibs -p$pkg -V"$pkg (= ${DEB_VERSION})" -X/usr/lib/${DEB_HOST_MULTIARCH}/plugin -- -q -O/dev/null

	if [ -e $PKGDIR/shlibs ]
	then
		mv $PKGDIR/shlibs $PKGDIR/shlibs.2
		# output shlibs entries from the first file
		# output shlibs entries from the second file if they are not in the first file
		debian/merge_shlibs.pl $PKGDIR/shlibs.1 $PKGDIR/shlibs.2 > $PKGDIR/shlibs
	fi
	rm -f $PKGDIR/shlibs.1
	rm -f $PKGDIR/shlibs.2

}


for pkg in `dh_listpackages`
do
	make_shlibs $pkg
done


